/*
  * Author: Alex Ferguson
  * Created: 13/02/25

  * Title: B31DG Assignment 1

  * Description: 
  * This program generates a waveform on two GPIO pins which can be viewed via an oscilloscope 
  * or visually via LEDs. 
  * 
  * The waveform is controlled with 2 push buttons. The first button enables or disables the output
  * and the second one toggles between the regular and alternative waveforms. The alternative waveform
  * mode for this program produces the original waveform in reverse i.e. from largest pulse to smallest 
  * pulse 
  * 
  * This program also includes a debug timing mode and a production timing mode. The debug timing mode
  * slows the waveform timings down by a factor of 1000 and this is controlled by setting DEBUG_TIMING
  * to 0 (production) or 1 (debug). The debug timing allows for the program to be debugged visually via 
  * the LEDs
  *
*/

#include <stdio.h>
#include <stdint.h> 
#include "freertos/FreeRTOS.h"
#include "driver/gpio.h"
#include "esp_timer.h"
#include "esp_log.h"
#include "rom/ets_sys.h"
#include "esp_intr_types.h"

#define DEBUG_TIMING 0
#define DEBUG_SCALING 1000
#define HIGH 1
#define LOW 0


/* 
	conditional compilation statements for debug timing and production timings
    debug timing multplies pulse timings by DEBUG_SCALING factor */
#if DEBUG_TIMING
    const int dataOnInitial = 600 * DEBUG_SCALING;
    const int dataOff = 500 * DEBUG_SCALING;
    const int idleTime = 3500 * DEBUG_SCALING;
    const int tSync = 50 * DEBUG_SCALING;
#else
    const int dataOnInitial = 600;
    const int dataOff = 500;
    const int idleTime = 3500;
    const int tSync = 50; 
#endif

const uint8_t pulseCount = 13;		// number of pulse to be generated by the waveform
const uint8_t debounceTime = 50;	// debounce time for output enable and output select buttons
const uint8_t outputEnablePin = 12;	// output enable push button pin
const uint8_t outputSelectPin = 14;	// output select push button pin

const uint8_t data = 25; 	// data LED pin
const uint8_t sync = 26;	// synce LED pin

// volatile variables for button press interrupts
volatile bool enableState = false;  	// button state variables for enable and select
volatile bool selectState = false; 

volatile unsigned long buttonTime = 0;	 
volatile unsigned long lastButtonTime = 0;


// isr routines triggered when one of the push buttons are pressed 
static void IRAM_ATTR outputEnable(void *arg)
{   
    // debounce for buttons 
    buttonTime = esp_timer_get_time(); // get time elapsed since start of the program 
    if(buttonTime - lastButtonTime > debounceTime)  /* check if time between button presses is  
    {                                                  greater than threshold to filter unwanted   
        enableState = !enableState;                    button presses. */
        lastButtonTime = buttonTime;
    }
}

static void IRAM_ATTR outputSelect(void *arg)
{
    buttonTime = esp_timer_get_time();
    if (buttonTime - lastButtonTime > debounceTime)
    {
        selectState = !selectState;
        lastButtonTime = buttonTime;
    }
}

static void configure_pins(void)
{
    // reset gpio pins
    gpio_reset_pin(data);
    gpio_reset_pin(sync);
    gpio_reset_pin(outputEnablePin);
    gpio_reset_pin(outputSelectPin);
	
    // Set the GPIO as a input/output
    gpio_set_direction(data, GPIO_MODE_OUTPUT);
    gpio_set_direction(sync, GPIO_MODE_OUTPUT);
    gpio_set_direction(outputEnablePin, GPIO_MODE_INPUT);
    gpio_set_direction(outputSelectPin, GPIO_MODE_INPUT);

    // set up interrupt pins to trigger on falling edge 
    gpio_set_intr_type(outputEnablePin, GPIO_INTR_NEGEDGE);
    gpio_set_intr_type(outputSelectPin, GPIO_INTR_NEGEDGE);

    // set interrupt handlers and attach interrupts to the output select and output enable pins 
    gpio_install_isr_service(0);
    gpio_isr_handler_add(outputEnablePin, outputEnable, NULL);
    gpio_isr_handler_add(outputSelectPin, outputSelect, NULL);

    gpio_intr_enable(outputEnablePin);
    gpio_intr_enable(outputSelectPin);
}

int tOn(int n)
{
    // calculate the on time for the data signal based on the pulse number  
    int onTime = (dataOnInitial + ((n-1)*tSync));
    return onTime;
}

// function to generate the sync pulse signal
// Sets sync pin high for time determined by tSync
void syncPulse()
{
    gpio_set_level(sync, HIGH);
    ets_delay_us(tSync);
    gpio_set_level(sync, LOW);
}

// function to generate the original waveform
void waveformGen()
{
    gpio_set_level(data, HIGH);
    ets_delay_us(dataOnInitial);
    gpio_set_level(data, LOW);
    ets_delay_us(dataOff);
    for(int iter = 2; iter <= pulseCount; iter++)
    {
        gpio_set_level(data, HIGH);
        ets_delay_us(tOn(iter));
        gpio_set_level(data, LOW);
        ets_delay_us(dataOff);
    }
}

/* Generate a reversed form of the data waveform (from the largest pulse to the shortest) 
   until the Output Select push button is pressed again */
void waveformGenAlt()
{
    for(int iter = (pulseCount); iter > 0; iter--)
    {
        gpio_set_level(data, HIGH);
        ets_delay_us(tOn(iter));
        gpio_set_level(data, LOW);
        ets_delay_us(dataOff);
    }
}

void app_main(void)
{
    configure_pins();

    //main loop
    while(1)
    {  
		/* executes when only enable button has been pressed and calls the original waveform
		generation function to generate the waveform on the gpio pin */
        if((enableState == true)&&(selectState == false))
        {
            syncPulse();
            waveformGen();
            ets_delay_us(idleTime);
        }
		/* executes when both enable and select button have been pressed and calls the alternative
		waveform generation function */
        if((enableState == true)&&(selectState == true))
        {
            syncPulse();
            waveformGenAlt();
            ets_delay_us(idleTime);
        }
    }
}
